<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <link rel="icon" href="/assets/imgs/icon.png" />
    <title>年会抽奖程序</title>
    <link rel="stylesheet" href="./css/style.css" />
  </head>
  <body>
    <canvas id="canvas"></canvas>
    <div id="container">
      <!-- 选中菜单结构 start-->
      <div id="menu">
        <button id="table">TABLE</button>
        <button id="sphere">SPHERE</button>
        <button id="helix">HELIX</button>
        <button id="grid">GRID</button>
      </div>
      <!-- end -->
    </div>
    <script src="./js/star-bg.js"></script>
    <script src="./js/three.min.js"></script>
    <script src="./js/data.js"></script>
    <script type="module">
      /**
       * 初始化引入所有依赖
       **/
      import { CSS3DRenderer, CSS3DObject } from "./js/CSS3DRenderer.js";
      import { TrackballControls } from "./js/TrackballControls.js";
      import TWEEN from "./js/tween.module.js";

      /**
       * @空间复杂度  S(n) = o(1);
       * @时间复杂度  T(n) = O(1);
       */

      /**
       * [users 用户数据]
       * @type {Array}
       * @element 五个一组 [ 姓名 英文 工号 所在列 所在行 ]
       * @element 五个一组 [ symbol detail1 detail2 columnInfo colInfo ]
       *
       * [ scene camera renderer ] the three basic component of three.js
       * [ controls trackballControls obj ]
       *
       * [objects save CSS3D domElem]
       * @type {Array}
       * scene - 环境对象
       * camera - 相机对象
       * renderer - 渲染器对象
       * controls - 轨道控制器对象
       * [targets save the four kinds vertices]
       * @type {Object}
       * [ table sphere helix grid ] transform CSS3D elem'position to one of these for animation
       */
      let scene, camera, renderer, controls;
      // 保存 CSS3D 所有的 domElem
      const objects = [];
      // 保存四种形式的 Objects3D 对象信息
      const targets = {
        grid: [],
        helix: [],
        table: [],
        sphere: [],
      };

      /**
       * 布局方式
       */
      const LAYOUT_MODE = {
        表格: "table",
        网格: "grid",
        球体: "sphere",
        螺旋: "helix",
      }
      // 初始化布局
      let curLayout = LAYOUT_MODE.表格;

      init();
      animation();

      /**
       * [init initialize scene && create animation && set constrol]
       *
       * [camera perspective camera]
       * @param filedView
       * @param aspect
       * @param near clipping plane
       * @param far clipping plane
       * @type {THREE}
       *
       * [renderer CSS3DRenderer only used to tranform domElem to 3D model]
       * WebGLoutput the father node of domElem container
       * @type {THREE}
       *
       * [controls create trackball control]
       * controls.minDistance = 500;  the camera min distance in Z Axis
       * controls.maxDistance = 6000; the camera max distance in Z Axis
       * @type {THREE}
       */

      function init() {
        const felidView = 40;
        const width = window.innerWidth;
        const height = window.innerHeight;
        const aspect = width / height;
        const nearPlane = 1;
        const farPlane = 1000;
        const WebGLoutput = document.getElementById("container");

        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(
          felidView,
          aspect,
          nearPlane,
          farPlane
        );
        camera.position.z = 3000;

        console.log('camera.position: ', camera.position);

        renderer = new CSS3DRenderer();
        renderer.setSize(width, height);
        renderer.domElement.style.position = "absolute";
        WebGLoutput.appendChild(renderer.domElement);

        controls = new TrackballControls(camera, renderer.domElement);

        controls.rotateSpeed = 1;
        controls.staticMoving = true;
        controls.minDistance = 500;
        controls.maxDistance = 6000;
        controls.addEventListener("change", render);

        /**
         * [i 0 5 10 .....]
         * [len iterator count]
         * @type {Number}
         *
         * [element dom element]
         * [backgroundColor create a random color of g from 0.25 to 0.75]
         *
         * [number order]
         * @type {[int]}
         *
         * [symbol example: H element]
         * @type {[string]}
         *
         * [detail fullname && quality]
         * @type {[string && float]}
         *
         *[object transform domElem to CSS3D object]
         * @type {THREE}
         * @position vector3( value1, value2, value3 ) [value: -2000 ~ 2000]
         *
         */
        let i = 0;
        let len = users.length;
        // 生成 118 个元素
        for (let i = 0; i < len; i += 5) {
          const element = document.createElement("div");
          element.className = "element";
          element.style.backgroundColor = `rgba( 0, 127, 127, ${
            Math.random() * 0.5 + 0.25
          } )`;

          const number = document.createElement("div");
          // 用户 id
          number.className = "wkno";
          number.textContent = i / 5 + 1;
          element.appendChild(number);

          const symbol = document.createElement("div");
          // 中文名
          symbol.className = "username";
          symbol.textContent = users[i];
          element.appendChild(symbol);

          const detail = document.createElement("div");
          // 邮箱前缀
          detail.className = "emailprefix";
          detail.innerHTML = `${users[i + 1]}<br/>${users[i + 2]}`;
          element.appendChild(detail);

          const object = new CSS3DObject(element);
          object.position.x = Math.random() * 4000 - 2000;
          object.position.y = Math.random() * 4000 - 2000;
          object.position.z = Math.random() * 4000 - 2000;
          scene.add(object);

          objects.push(object);
        }

        const objLength = objects.length;

        createGridVertices();
        createTableVertices();
        createHelixVertices();
        createSphereVertices();

        /**
         * 生成排列的表格元素
         * @type {[number]}
         *
         * [createTableVertices create table format vertices]
         *
         * [createTableVertices create sphere format vertices]
         *
         * [createTableVertices create helix format vertices]
         *
         * [createTableVertices create grid format vertices]
         */
        // 生成 table 格式的元素
        function createTableVertices() {
          let i = 0;

          for (; i < len; i += 5) {
            const object = new THREE.Object3D();
            /**
             * 如果想变宽变高，可以通过修改这里的 160 和 200，但是需要修改 CSS 中的 .element 的宽高现在是（140 和 180）
             **/
            object.position.x = users[i + 3] * 160 - 1360;
            object.position.y = -users[i + 4] * 200 + 900;
            object.position.z = 0;

            targets.table.push(object);
          }
        }

        function createSphereVertices() {
          let i = 0;
          const vector = new THREE.Vector3();

          for (; i < objLength; ++i) {
            let phi = Math.acos(-1 + (2 * i) / objLength);
            let theta = Math.sqrt(objLength * Math.PI) * phi;
            const object = new THREE.Object3D();

            object.position.x = 800 * Math.cos(theta) * Math.sin(phi);
            object.position.y = 800 * Math.sin(theta) * Math.sin(phi);
            object.position.z = -800 * Math.cos(phi);

            // rotation object

            vector.copy(object.position).multiplyScalar(2);
            object.lookAt(vector);
            targets.sphere.push(object);
          }
        }

        function createHelixVertices() {
          let i = 0;
          const vector = new THREE.Vector3();

          for (; i < objLength; ++i) {
            let phi = i * 0.213 + Math.PI;

            const object = new THREE.Object3D();

            object.position.x = 800 * Math.sin(phi);
            object.position.y = -(i * 8) + 500;
            object.position.z = 800 * Math.cos(phi + Math.PI);

            object.scale.set(1.1, 1.1, 1.1);

            vector.x = object.position.x * 2;
            vector.y = object.position.y;
            vector.z = object.position.z * 2;

            object.lookAt(vector);

            targets.helix.push(object);
          }
        }

        function createGridVertices() {
          let i = 0;

          for (; i < objLength; ++i) {
            const object = new THREE.Object3D();

            object.position.x = 360 * (i % 5) - 800;
            object.position.y = -360 * (((i / 5) >> 0) % 5) + 700;
            object.position.z = -700 * ((i / 25) >> 0);

            targets.grid.push(object);
          }
        }

        const gridBtn = document.getElementById("grid");
        const tableBtn = document.getElementById("table");
        const helixBtn = document.getElementById("helix");
        const sphereBtn = document.getElementById("sphere");

        gridBtn.addEventListener(
          "click",
          function () {
            curLayout = LAYOUT_MODE.网格;
            transform(targets.grid, 2000);
          },
          false
        );
        tableBtn.addEventListener(
          "click",
          function () {
            curLayout = LAYOUT_MODE.表格;
            transform(targets.table, 2000);
          },
          false
        );
        helixBtn.addEventListener(
          "click",
          function () {
            curLayout = LAYOUT_MODE.螺旋;
            transform(targets.helix, 2000);
          },
          false
        );
        sphereBtn.addEventListener(
          "click",
          function () {
            curLayout = LAYOUT_MODE.球体;
            transform(targets.sphere, 2000);
            // TODO: 这里处理相机旋转以及停止旋转，并封装一下
            let ang = 0;
            let timer;
            setTimeout(() => {
              timer = setInterval(() => {
                // 旋转相机位置，球体就旋转了
                ang += Math.PI / 50;
                camera.position.x = Math.cos(ang) * 3000;
                camera.position.z = Math.sin(ang) * 3000;
                camera.position.y = 0;
              }, 10);
            }, 2000);
            setTimeout(() => {
              clearInterval(timer);
              camera.position.x = 0;
              camera.position.z = 3000;
              camera.position.y = 0;
              ang = 0;
            }, 10000);
          },
          false
        );

        // 如果是表格布局，就随机替换，如果不是就不动
        function updateRandomElements(numElementsToUpdate) {
          if (curLayout !== LAYOUT_MODE.表格) return;
          // 为了随机更新，创建一个包含所有索引的数组
          const indices = [];
          for (let i = 0; i < objects.length; i++) {
            indices.push(i);
          }

          // 随机选择要更新的元素的索引
          const indicesToUpdate = [];
          for (let i = 0; i < numElementsToUpdate; i++) {
            const randomIndex = Math.floor(Math.random() * indices.length);
            indicesToUpdate.push(indices.splice(randomIndex, 1)[0]);
          }

          // 更新选定的元素
          indicesToUpdate.forEach((ind) => {
            // 随机获取一个用户数据，按照 5 来取模，是因为每个用户数据占用 5 个元素
            const _index  = 5 * Math.floor(Math.random() * 20);
             // TODO: 需要实现获取用户数据的逻辑
            const userData = [users[_index], users[_index + 1], users[_index + 2], users[_index + 3], users[_index + 4]];

            const element = objects[ind].element;
            // 更新element的内容
            // 例如，更新用户名称和其他信息
            // TODO: 这里只替换了用户名，其他的后续真实数据再进行替换
            element.querySelector('.username').textContent = userData[0];
            // ... 更新其他需要的DOM元素

            // 更新场景中的CSS3DObject
            const object = objects[ind];
            scene.remove(object);
            const newObject = new CSS3DObject(element);
            newObject.position.copy(object.position);
            newObject.rotation.copy(object.rotation);
            scene.add(newObject);
            objects[ind] = newObject;
            // 更新元素内容的同时，添加高亮动画
            element.classList.add('highlight');

            // 设置一个定时器，在1秒后移除高亮类
            setTimeout(() => {
              element.classList.remove('highlight');
            }, 1000);
          });

          // 重新渲染场景
          renderer.render(scene, camera);
        }

        // 设置定时器周期性调用 updateRandomElements 函数

        window.addEventListener("resize", onWindowResize, false);
        // default animation
        transform(targets.table, 2000);
        // 等所有布局都完成之后，再开始随机更新
        setTimeout(() => {
          // 每 10 秒随机更新 10 个元素的内容和位置
          setInterval(() => updateRandomElements(20), 1000);
        }, 3000);

        /**
         * [transform transform domelem'position to target'position]
         * @param     {[array]}    targets  [description]
         * @param     {[number]}    duration [description]
         * @return    {[type]}             [description]
         */

        function transform(targets, duration) {
          TWEEN.removeAll();

          for (let i = 0; i < objLength; ++i) {
            let object = objects[i];
            let target = targets[i];

            new TWEEN.Tween(object.position)
              .to(
                {
                  x: target.position.x,
                  y: target.position.y,
                  z: target.position.z,
                },
                Math.random() * duration + duration
              )
              .easing(TWEEN.Easing.Exponential.InOut)
              .start();

            new TWEEN.Tween(object.rotation)
              .to(
                {
                  x: target.rotation.x,
                  y: target.rotation.y,
                  z: target.rotation.z,
                },
                Math.random() * duration + duration
              )
              .easing(TWEEN.Easing.Exponential.InOut)
              .start();
          }

          // 这个补间用来在位置与旋转补间同步执行，通过onUpdate在每次更新数据后渲染scene和camera
          new TWEEN.Tween({})
            .to({}, duration * 2)
            .onUpdate(render)
            .start();
        }

        render();
      }

      /**
       * [onWindowResize reset the scene size && camera.aspect && re render]
       * @return
       */
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
        render();
      }

      /**
       * [animation update all tween && controls]
       */
      function animation() {
        TWEEN.update();
        controls.update();
        requestAnimationFrame(animation);
      }

      function render() {
        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>
